1如何实现一个链表
	class Node(){
		Node next = null;
		int data;
		public Node(int data){
			this.data = data;
		}
	}
	class MylinkedList(){
		Node head = null;
		public void addNode(int d){}
		public boolean deleteNode(int index){}
		public int length(){}
	}
2：如何删除重复元素：
	1：两重，第一重遍历，第二重比较
	外循环正常遍历链表，假设外循环当前遍历的节点为cur，内循环从cur开始遍历，若碰到cur所指向的结点值相同，则删除这个重复的结点
	
	2：采用hashtable
3：如何找出单链表中倒数第K个元素，
	两个指针，第一个指针先走 k-1步，然后第二个指针和第一个指针一起走，直到第一个指针走到头为止
4：如何寻找链表中的中间结点
	两个指针，一个一次走一格，一个一次走两格，走的快的先到头，则长度为奇数时，即为中间，为偶数时，中间节点和中间节点的下一个节点为所有链表的中间节点
5：反转一个链表
  pre = null;
  cur = head;
  while(cur != null){
  	Node next = cur.next;
  	cur.next = pre;
  	pre = cur;
  	cur = next;	
  }
6:如何在不知道头指针的情况下删除指定节点
	1：若带上出的节点为链表尾节点，则无法删除，因为删除后无法使其前驱节点的 next指针为空
	2：若待删除的节点不是尾节点，则可以通过交换这个节点与其后继节点的值，然后删除后继节点   
5：如何检测一个链表是否有环，并找到环的入口的位置
	判断有环：两个指针，slow和fast，slow一次走一格，fast一次走两格，相遇，slow = fast，则判断为有环
	环的入口位置：假设链表头到环的入口位置为a,相遇的地方距离环的入口位置x,环长为r,整个链表的长度为L,设快指针转了N圈,设慢的走了，s的距离，快的走了2s距离
			 a+x = s
			 2s = s + nr
			 
			 a+x = nr = (n-1)*r+L-a
			 a = (n-1)*r + L-a-x; //表示一个指针从相遇的地方开始，另一个指针从头开始，第一个碰到头的地方就是环的入口位置
6：如何判断两个链表是否相交，并求出相交节点位置
	判断是否相交：链表相交，他们有相同的尾节点
	相交节点位置：一个指针先走(len1-len2)，另一个指针从链表的头开始走，第一次碰到的位置就是相交节点位置

